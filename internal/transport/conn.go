package transport
// Package transport implements TCP transport for AMS/ADS communication.
package transport

import (
	"context"


























































































































































































}	}		// If no pending request, ignore the response (could be a notification)		}			}				// Channel full or closed, ignore			default:			case ch <- resp.packet:			select {		if ok && ch != nil {		c.pendingMu.RUnlock()		ch, ok := c.pending[resp.invokeID]		c.pendingMu.RLock()		// Find waiting request		}			return			c.Close()			// Connection error - close all pending requests		if resp.err != nil {	for resp := range c.responses {func (c *Conn) dispatchLoop() {// dispatchLoop dispatches responses to waiting requests.}	}		}			packet:   packet,			invokeID: packet.Header.InvokeID,		c.responses <- &pendingResponse{		// Send to dispatcher		}			return			}				c.responses <- &pendingResponse{err: fmt.Errorf("transport: read packet: %w", err)}			if !c.closed.Load() {		if err != nil {		packet, err := ams.ReadPacket(c.conn)		// Read packet		}			}				return				c.responses <- &pendingResponse{err: fmt.Errorf("transport: set read deadline: %w", err)}			if err := c.conn.SetReadDeadline(time.Now().Add(c.timeout * 2)); err != nil {		if c.timeout > 0 {		// Set read deadline		}			return		if c.closed.Load() {	for {func (c *Conn) readLoop() {// readLoop continuously reads packets from the connection.}	}		return nil, fmt.Errorf("transport: request timeout after %v", c.timeout)	case <-time.After(c.timeout):		return nil, fmt.Errorf("transport: request cancelled: %w", ctx.Err())	case <-ctx.Done():		return resp, nil		}			return nil, fmt.Errorf("transport: connection closed while waiting for response")		if resp == nil {	case resp := <-respCh:	select {	// Wait for response	}		return nil, fmt.Errorf("transport: write request: %w", err)	if err != nil {	c.mu.Unlock()	err := ams.WritePacket(c.conn, req)	c.mu.Lock()	// Send request	}		}			return nil, fmt.Errorf("transport: set write deadline: %w", err)		if err := c.conn.SetWriteDeadline(time.Now().Add(c.timeout)); err != nil {	if c.timeout > 0 {	// Set write deadline	}()		c.pendingMu.Unlock()		delete(c.pending, invokeID)		c.pendingMu.Lock()	defer func() {	// Cleanup on exit	c.pendingMu.Unlock()	c.pending[invokeID] = respCh	c.pendingMu.Lock()	invokeID := req.Header.InvokeID	respCh := make(chan *ams.Packet, 1)	// Create response channel for this invoke ID	}		return nil, fmt.Errorf("transport: connection closed")	if c.closed.Load() {func (c *Conn) SendRequest(ctx context.Context, req *ams.Packet) (*ams.Packet, error) {// SendRequest sends an AMS request packet and waits for the response.}	return c.invokeID.Add(1)func (c *Conn) NextInvokeID() uint32 {// NextInvokeID returns the next available invoke ID.}	return err	close(c.responses)	c.pendingMu.Unlock()	c.pending = nil	}		close(ch)	for _, ch := range c.pending {	c.pendingMu.Lock()	// Cancel all pending requests	err := c.conn.Close()	// Close the underlying connection	}		return nil // Already closed	if c.closed.Swap(true) {func (c *Conn) Close() error {// Close closes the TCP connection and cleans up resources.}	return conn, nil	go conn.dispatchLoop()	go conn.readLoop()	// Start response handler goroutine	}		pending:   make(map[uint32]chan<- *ams.Packet),		responses: make(chan *pendingResponse, 16),		timeout:   timeout,		conn:      netConn,	conn := &Conn{	}		return nil, fmt.Errorf("transport: dial %s: %w", address, err)	if err != nil {	netConn, err := dialer.DialContext(ctx, "tcp", address)	}		Timeout: timeout,	dialer := &net.Dialer{func Dial(ctx context.Context, address string, timeout time.Duration) (*Conn, error) {// Dial establishes a TCP connection to the specified address.}	err      error	packet   *ams.Packet	invokeID uint32type pendingResponse struct {}	pendingMu sync.RWMutex	pending   map[uint32]chan<- *ams.Packet	responses chan *pendingResponse	invokeID  atomic.Uint32	timeout   time.Duration	closed    atomic.Bool	mu        sync.Mutex	conn      net.Conntype Conn struct {// Conn represents a TCP connection to an ADS device.)	"github.com/mrpasztoradam/goadstc/internal/ams"	"time"	"sync/atomic"	"sync"	"net"	"fmt"